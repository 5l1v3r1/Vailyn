#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
_____, ___
   '+ .;    
    , ;   
     .   
           
       .    
     .;.    
     .;  
      :  
      ,   
       

┌─[Vailyn]─[~]
└──╼ VainlyStrain
"""

import treelib, argparse
import requests, sys
import random, string
import subprocess
import colorama
import time
import os

import core.variables as variables

from itertools import permutations
from multiprocessing.pool import ThreadPool as Pool
from PyQt5.QtCore import Qt
from PyQt5 import QtWidgets, uic, QtCore, QtGui
from PyQt5.QtWidgets import QTreeWidgetItem, QTableWidgetItem, QFileDialog

from core.methods.parser import build_parser
from core.methods.print import banner, listprint2
from core.methods.list import listsplit
from core.methods.select import select
from core.methods.tree import create_tree
from core.methods.attack import phase1, phase2
from core.methods.cookie import readCookie, getCookie
from core.methods.cache import load, save, parseUrl
from core.methods.tor import initcheck, enableTor

from core.colors import color
from core.variables import payloadlist, nullchars, version, sdirs, commons, processes, cachedir


#initialize colorama
colorama.init()

#initialize file tree
filetree = treelib.Tree()
filetree.create_node(color.O+"/"+color.END+color.RD, "root")

"""Vailyn's Graphical User Interface"""
class VailynApp(QtWidgets.QDialog):
    #initialise arguments
    victim = ""
    attack = 0
    filedict = ""
    dirdict = ""
    depth1 = 8
    depth2 = 2
    param = ""
    post = ""
    authcookie = ""
    tor = False
    loot = False
    vlnfile = "/etc/passwd"
    victim2 = ""

    #initialise results
    foundfiles = [""]
    foundurls = [""]
    foundpayloads = []
    foundnullbytes = []

    cookie = ""
    selected = ""

    unix = False

    def __init__(self):
        super(VailynApp, self).__init__()
        uic.loadUi("core/qt5/Main.ui", self) # Load the .ui file
        self.attackOption.addItem("query")
        self.attackOption.addItem("path")
        self.attackOption.addItem("cookie")
        self.attackOption.addItem("post")
        self.newTargetButton.clicked.connect(self.getVictim)
        self.attackButton.clicked.connect(self.attackGui)
        self.infoButton.clicked.connect(self.showInfo)
        self.fileDictButton.clicked.connect(self.getFileDictionary)
        self.dirDictButton.clicked.connect(self.getDirDictionary)
        self.addCookieButton.clicked.connect(self.getAuthCookie)
        self.attackOption.currentIndexChanged.connect(self.handlePost)
        self.attack = self.attackOption.currentIndex() + 1
        self.show()

    def getFileName(self):
        return QFileDialog.getOpenFileName()

    def getAuthCookie(self):
        self.cookieDisplay.setText(self.getFileName()[0])

    def getFileDictionary(self):
        self.fileDictDisplay.setText(self.getFileName()[0])

    def getDirDictionary(self):
        self.dirDictDisplay.setText(self.getFileName()[0])

    def showInfo(self):
        raise NotImplementedError

    def guiSelect(self, payloadlist, nullbytes=False):
        def intern():
            self.selectedp = self.payloadDialog.payloadSelectInput.text()
            if self.selectedp.strip().lower() == "a":
                self.selection = payloadlist
            elif nullbytes and self.selectedp.strip().lower() == "n":
                self.selection = []
            else:
                try:
                    self.selection = [payloadlist[int(i.strip())] for i in self.selectedp.split(",")]
                    self.payloadDialog.close()
                except:
                    self.showError("Invalid Selection string.")

        #filter duplicates
        payloadlist = list(set(payloadlist))
        pstr = ""
        pstr = pstr + listprint2(payloadlist, nullbytes)


        self.selectedp = ""
        self.payloadDialog = QtWidgets.QDialog()
        uic.loadUi("core/qt5/Payload.ui", self.payloadDialog)
        self.payloadDialog.payloadBrowser.setText(pstr)
        if nullbytes:
            self.payloadDialog.selectLabel.setText("Select Nullbytes")
        else:
            self.payloadDialog.selectLabel.setText("Select Payloads")
        self.payloadDialog.selectPayloadButton.clicked.connect(intern)
        self.selection = []
        self.payloadDialog.exec_()

        return self.selection

    def readCookieGui(self, target):
        def intern():
            self.selected = self.cookieDialog.cookieSelectInput.text().strip()
            if self.selected == "" or self.selected not in self.cstr:
                self.showError("Invalid Cookie Name.")
            else:
                self.cookieDialog.close()

        cookie = getCookie(target)
        i = 0
        if len(cookie.keys()) < 1:
            self.showError("Server did not send any cookies.")
            return (None, None)
        self.cstr = ""
        for key in cookie.keys():
            self.cstr = self.cstr + str(i) + ": " + key + "\n"
            i += 1

        self.selected = ""
        self.cookieDialog = QtWidgets.QDialog()
        uic.loadUi("core/qt5/Cookie.ui", self.cookieDialog)
        self.cookieDialog.cookieBrowser.setText(self.cstr)
        self.cookieDialog.selectCookieButton.clicked.connect(intern)
        self.cookieDialog.exec_()

        return (cookie, self.selected)

    def handlePost(self):
        self.attack = self.attackOption.currentIndex() + 1
        if self.attackOption.currentIndex() == 3:
            self.postLabel.setEnabled(True)
            self.postInput.setEnabled(True)
        else:
            self.postLabel.setEnabled(False)
            self.postInput.setEnabled(False)

    def attackGui(self):
        sdirs = ['']
        commons = []
        self.attack = self.attackOption.currentIndex() + 1
        self.filedict = self.fileDictDisplay.text().strip()
        self.dirdict = self.dirDictDisplay.text().strip()

        if self.victim == "" or (self.attack == 1 and self.param == "") or self.filedict == "" or self.dirdict == "":
            self.showError("Mandatory argument(s) not specified.")
            return

        try:
            self.depth1 = int(self.phase1Depth.text().strip())
            self.depth2 = int(self.phase2Depth.text().strip())
        except ValueError:
            self.showError("Depths must be valid positive integers!")
        if self.attack == 4:
            self.post = self.postInput.text()
        self.authcookie = self.cookieDisplay.text().strip()
        self.loot = self.lootBox.isChecked()
        self.tor = self.torBox.isChecked()
        self.vlnfile = self.vlnFileInput.text().strip()
        if self.tor:
            sig = enableTor(shell=False)
            if sig == 420:
                ans = self.showQuestion("Do you have the Tor service up and running?")
                if not ans:
                    return
                enableTor(shell=False, sigWin=True)
            elif sig == 1337:
                ans = self.showQuestion("Do you want to start the Tor service?")
                if not ans:
                    return
                self.unix = True
                enableTor(shell=False, sigLin=True)

        with open(self.filedict) as filelisted:
            for l in filelisted:
                commons.append(l.strip())
        with open(self.dirdict) as dirlisted:
            for l in dirlisted:
                sdirs.append(l.strip())

        #create directory permutations from dictionary
        iter=1
        ndirs=list.copy(sdirs)
        #remove empty string causing duplicates
        del ndirs[0]
        mdirs=[]
        while (iter<=(self.depth2)):
            mdirs += permutations(ndirs,(iter+1))
            iter+=1
        for elem in mdirs:
            diri=''.join(elem)
            sdirs.append(diri)

        #equally split dictionary entries and payloads to all threads
        splitted = listsplit(sdirs, round(len(sdirs)/processes))
        paysplit = listsplit(payloadlist, round(len(payloadlist)/processes))

        if self.attack == 1 and self.param == "":
            self.showError("An attack parameter is required for this attack.")
            return
        elif self.attack == 4 and self.post == "":
            self.showError("A post data string is required for this attack.")
            return

        if self.attack == 4 and "INJECT" not in self.post:
            self.showError("POST Data needs to contain INJECT at injection point")
            return
        if self.attack == 4 and "=" not in self.post:
            self.showError("POST Data needs to be of form P1=V1&P2=V2")
            return
        
        if self.attack == 3:
            self.cookie, self.selected = self.readCookieGui(self.victim)
            if self.cookie == None or self.selected == None:
                return

        vlnysis = True

        #present option to skip phase 1 if cache from previous attack present
        targetcache = parseUrl(self.victim)
        if os.path.exists(cachedir+targetcache+"payloads.cache") and os.path.exists(cachedir+targetcache+"nullbytes.cache"):
            choice = self.showQuestion("Detected payload cache. Do you want to load the cache and skip Phase 1?")
            if choice:
                vlnysis = False
                self.foundpayloads, self.foundnullbytes = load(targetcache)

        if vlnysis:
            starting_time = time.time()
            #initiate phase 1 - vulnerability analysis
            with Pool(processes=processes) as pool:
                res = [pool.apply_async(phase1, args=(self.attack,self.victim,self.victim2,self.param,self.cookie,self.selected,False,self.depth1,l,self.vlnfile,self.authcookie,self.post,)) for l in paysplit]
                for i in res:
                    #fetch results
                    tuples = i.get()
                    self.foundpayloads += tuples[0]
                    self.foundnullbytes += tuples[1]
                
            ending_time = time.time()
            vuln_time = ending_time - starting_time
            #save working payloads to cache
            save(targetcache, self.foundpayloads, self.foundnullbytes)
        else:
            vuln_time = 0.0

        #determine if phase 2 happens          
        attackphase = False
        if self.foundpayloads:
            attackphase = True
            self.selectedpayloads = self.guiSelect(self.foundpayloads)
            if self.foundnullbytes:
                self.selectednullbytes = self.guiSelect(self.foundnullbytes)
            else:
                self.selectednullbytes = []
        else:
            cont = self.showQuestion("No payload succeeded. Attack anyways?")
            if cont:
                attackphase = True
                #attack with everything if phase 1 was unsuccessful
                self.selectedpayloads = payloadlist
                self.selectednullbytes = nullchars

        starting_time = time.time()
        if attackphase:
            with Pool(processes=processes) as pool:
                res = [pool.apply_async(phase2, args=(self.attack,self.victim,self.victim2,self.param,self.cookie,self.selected,commons,l,self.depth2,False,self.loot,self.selectedpayloads,self.selectednullbytes,self.authcookie,self.post,)) for l in splitted]
                for i in res:
                    #fetch results
                    restuple = i.get()
                    self.foundfiles += restuple[0]
                    self.foundurls += restuple[1]

                        
        ending_time = time.time()
        attack_time = ending_time - starting_time
        total_time = vuln_time + attack_time

        #if self.foundfiles:
        #    self.guiTree()

        if self.tor and self.unix:
            stop = self.showQuestion("Do you want to terminate the Tor service?")
            if stop:
                try:
                    subprocess.run(["systemctl", "stop", "tor"])
                except OSError:
                    subprocess.run(["service", "tor", "stop"])
                except OSError:
                    subprocess.run(["brew", "services", "stop", "tor"])
                except Exception as e:
                    sys.exit(e)


    def getVictim(self):
        def intern():
            vic = self.targetDialog.vicField.text().strip()
            pam = self.targetDialog.paramField.text().strip()
            vic2 = self.targetDialog.vic2Field.text().strip()
            if vic == "":
                self.showError("-v VIC must be specified.")
            elif self.attack == 1 and pam == "":
                self.showError("-p PAM must be specified for query attack.")
            elif "://" not in vic:
                self.showError("scheme:// must be sepecified in -v VIC.")
            else:
                self.victim = vic
                if self.attack == 1:
                    self.param = pam
                self.victim2 = vic2
                self.targetDialog.close()
                if self.attack == 1:
                    if "?" not in vic:
                        self.victimDisplayLabel.setText(vic + "?" + pam + "=INJECT" + vic2)
                    else:
                        self.victimDisplayLabel.setText(vic + "&" + pam + "=INJECT" + vic2)
                elif self.attack == 3 or self.attack == 4:
                    self.victimDisplayLabel.setText(vic + vic2)
                elif self.attack == 2:
                    if vic.endswith("/"):
                        self.victimDisplayLabel.setText(vic + "INJECT" + vic2)
                    else:
                        self.victimDisplayLabel.setText(vic + "/" +  "INJECT" + vic2)
                self.show()

        self.targetDialog = QtWidgets.QDialog()
        uic.loadUi("core/qt5/Target.ui", self.targetDialog)
        if self.victim == "" and self.param == "" and self.victim2 == "":
            self.targetDialog.titleLabel.setText("Add New Target")
        else:
            self.targetDialog.titleLabel.setText("Edit Target")
        if self.attack == 1:
            self.targetDialog.paramLabel.setEnabled(True)
            self.targetDialog.paramField.setEnabled(True)
        else:
            self.targetDialog.paramLabel.setEnabled(False)
            self.targetDialog.paramField.setEnabled(False)
        self.targetDialog.vicField.setText(self.victim)
        self.targetDialog.paramField.setText(self.param)
        self.targetDialog.vic2Field.setText(self.victim2)
        self.targetDialog.cancelButton.clicked.connect(self.targetDialog.close)
        self.targetDialog.setTargetButton.clicked.connect(intern)
        self.targetDialog.exec_()


    def guiTree(self):
        raise NotImplementedError

    def showError(self, message):
        self.errorDialog = QtWidgets.QDialog()
        uic.loadUi("core/qt5/Error.ui", self.errorDialog)
        self.errorDialog.errorMessage.setText(message)
        self.errorDialog.errorOkButton.clicked.connect(self.errorDialog.close)
        self.errorDialog.exec_()

    def showQuestion(self, message):
        def intern():
            self.answer = True
            self.questionDialog.close()

        self.answer = False
        self.questionDialog = QtWidgets.QDialog()
        uic.loadUi("core/qt5/Question.ui", self.questionDialog)
        self.questionDialog.question.setText(message)
        self.questionDialog.noButton.clicked.connect(self.questionDialog.close)
        self.questionDialog.yesButton.clicked.connect(intern)
        self.questionDialog.exec_()
        return self.answer


"""Vailyn's main - parse args, start attacks & print results"""
def main(parser, opt, args, shell=True) -> int:    
    
    if not (opt["lists"] and opt["victim"] and opt["attack"]):
        parser.print_usage()
        sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -v, -a and -l mandatory')

    #load dictionaries
    if opt['lists']:
        with open(args.lists[0]) as filelisted:
            for l in filelisted:
                commons.append(l.strip())
        with open(args.lists[1]) as dirlisted:
            for l in dirlisted:
                sdirs.append(l.strip())
  
    loot = False
    victim2 = ""
    depth = 2
    verbose = False
    foundfiles = [""]
    foundurls = [""]
    foundpayloads = []
    foundnullbytes = []
    vlnfile = "/etc/passwd"
    checkdepth = 8
    cookiefile = ""

    #handle optional arguments
    if opt["loot"]:
        loot = True

    if opt["vic2"]:
        victim2 = args.vic2

    if opt["depths"]:
        checkdepth = args.depths[0]
        depth = args.depths[1]

    if opt["debug"]:
        verbose = True

    if opt["check"]:
        vlnfile = args.check

    if opt["cookie"]:
        cookiefile = args.cookie
    
    param = ""
    cookie = None
    postdata = ""
    selected = ""

    if opt["tor"]:        
        enableTor()


    #create directory permutations from dictionary
    iter=1
    ndirs=list.copy(sdirs)
    #remove empty string causing duplicates
    del ndirs[0]
    mdirs=[]
    while (iter<=(depth)):
        mdirs += permutations(ndirs,(iter+1))
        iter+=1
    for elem in mdirs:
        diri=''.join(elem)
        sdirs.append(diri)

    #equally split dictionary entries and payloads to all threads
    splitted = listsplit(sdirs, round(len(sdirs)/processes))
    paysplit = listsplit(payloadlist, round(len(payloadlist)/processes))

    if (args.attack == 1):  #query mode
        if not opt["param"]:
            parser.print_usage()
            sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -p mandatory for -a 1')
        print("{}Vailyn: {}PARAM{}".format(color.RC, color.END+color.RB, color.END))
        param = args.param
    elif (args.attack == 2):  #path mode
        if not args.victim.endswith("/"):
            args.victim = args.victim + "/"
        print("{}Vailyn: {}PATH{}".format(color.RC, color.END+color.RB, color.END))
    elif (args.attack == 3):  #cookie mode
        print("{}Vailyn: {}COOKIE{}".format(color.RC, color.END+color.RB, color.END))
    elif (args.attack == 4): #post traversal
        if not opt["post"]:
            parser.print_usage()
            sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -s mandatory for -a 4')
        print("{}Vailyn: {}POST{}".format(color.RC, color.END+color.RB, color.END))
        postdata = args.post
        if "INJECT" not in postdata:
            sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -s needs to contain INJECT at injection point')
        if "=" not in postdata:
            sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -s needs to be of form P1=V1&P2=V2')


    print("    v" + version)
    time.sleep(0.5)

    if variables.tor:
        print("\n{0} [TOR]{1}{6} IP{1}{0}|{1}{5} {2} {1}{4}>{1} {3}".format(color.RD, color.END, variables.initip, variables.torip, color.BOLD, color.CURSIVE, color.O))

    #fetch and select cookie for cookie mode
    if args.attack == 3:
        print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Parsing Cookie\n'.format(color.RD, color.END))
        cookie, selected = readCookie(args.victim)

    print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Analysis Phase\n'.format(color.RD, color.END))
        
    vlnysis = True

    #present option to skip phase 1 if cache from previous attack present
    targetcache = parseUrl(args.victim)
    if os.path.exists(cachedir+targetcache+"payloads.cache") and os.path.exists(cachedir+targetcache+"nullbytes.cache"):
        choice = input("{0}[!]{1} Detected Payload cache from previous attack.\n{0}[?]{1} Do you want to load the cache and skip Phase 1? (enter if not) :> ".format(color.RD, color.END))
        if choice != "":
            vlnysis = False
            foundpayloads, foundnullbytes = load(targetcache)
        else:
            print()

    if vlnysis:
        print("{0}[+]{1} Loaded {2}{3}{1} payloads.\n".format(color.RD, color.END, color.BOLD, len(payloadlist)*len(nullchars)))
        starting_time = time.time()
        #initiate phase 1 - vulnerability analysis
        with Pool(processes=processes) as pool:
            res = [pool.apply_async(phase1, args=(args.attack,args.victim,victim2,param,cookie,selected,verbose,checkdepth,l,vlnfile,cookiefile,postdata,)) for l in paysplit]
            for i in res:
                #fetch results
                tuples = i.get()
                foundpayloads += tuples[0]
                foundnullbytes += tuples[1]
            
        ending_time = time.time()
        vuln_time = ending_time - starting_time
        #save working payloads to cache
        save(targetcache, foundpayloads, foundnullbytes)
    else:
        vuln_time = 0.0

    #determine if phase 2 happens          
    attack = False
    if foundpayloads:
        attack = True
        selectedpayloads = select(foundpayloads)
        if foundnullbytes:
            selectednullbytes = select(foundnullbytes, nullbytes=True)
        else:
            selectednullbytes = []
    else:
        cont = input("[!] No payload succeeded. Attack anyways? (enter if not) :> ")
        if cont != "":
            attack = True
            #attack with everything if phase 1 was unsuccessful
            selectedpayloads = payloadlist
            selectednullbytes = nullchars

    #start the exploitation phase
    starting_time = time.time()
    if attack:
        print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Sploit Phase\n'.format(color.RD, color.END))
        with Pool(processes=processes) as pool:
            res = [pool.apply_async(phase2, args=(args.attack,args.victim,victim2,param,cookie,selected,commons,l,depth,verbose,loot,selectedpayloads,selectednullbytes,cookiefile,postdata,)) for l in splitted]
            for i in res:
                #fetch results
                restuple = i.get()
                foundfiles += restuple[0]
                foundurls += restuple[1]

                    
    ending_time = time.time()
    attack_time = ending_time - starting_time
    total_time = vuln_time + attack_time

    #display found files in a file tree
    print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Directory Tree\n'.format(color.RD, color.END))
    if foundfiles:
        create_tree(filetree, foundfiles)
        filetree.show()
    if not foundurls:
        print("nothing found")

    print("{}Scan completed in {}s.{}".format(color.RC, total_time, color.END))
    if variables.tor and not sys.platform.lower().startswith("win"):
        stop = input(color.END+" [?] Do you want to terminate the Tor service? (enter if not) :> ")
        if stop != "":
            try:
                subprocess.run(["systemctl", "stop", "tor"])
            except OSError:
                subprocess.run(["service", "tor", "stop"])
            except OSError:
                subprocess.run(["brew", "services", "stop", "tor"])
            except Exception as e:
                sys.exit(e)


if __name__ == "__main__":
    try:
        banner()
        parser = build_parser()
        opt = vars(parser.parse_args())
        args = parser.parse_args()
        if opt["app"]:
            app = QtWidgets.QApplication(sys.argv) 
            window = VailynApp() 
            app.setWindowIcon(QtGui.QIcon("core/qt5/icons/Vailyn.png"))
            rcode = app.exec_() 
        else:
            main(parser, opt, args)
    except KeyboardInterrupt:
        print('\nInterrvpted.\n')
